---
#    self_contained: yes
output:
  github_document:
    html_preview: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.width = 13,
  fig.height = 9 
)

set.seed(42)
```

```{r}
suppressPackageStartupMessages({
  library(readr)
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(sf)
  library(rnaturalearth)

  library(GenomicRanges)
  library(ggbio)
  library(plyranges)
})

source(here::here("utils.R"))
```

```{r}
# IBDmix desert coordinates from Table S8 of Chan et al., 202
# (https://ars.els-cdn.com/content/image/1-s2.0-S0092867420300593-mmc1.pdf)
# (https://ars.els-cdn.com/content/image/1-s2.0-S0092867420300593-figs4_lrg.jpg)

deserts_df <- tribble(
  ~chrom, ~start_ss, ~end_ss,   ~start_ibdmix, ~end_ibdmix,
  "chr1", 102200000, 114900000, 105400000,     120600000,
  "chr3", 76500000,  90500000,  74100000,      89300000,
  "chr7", 106300000, 124700000, 106200000,     123200000,
  "chr8", 53900000,  66000000,  49400000,      66500000
) %>% pivot_longer(cols = c(starts_with("start_"), starts_with("end_")),
                   names_to = c(".value", "method"), names_sep = "_")

# convert S* and IBDmix coordinates above into GRanges objects
ss_deserts_gr <- filter(deserts_df, method == "ss") %>% makeGRangesFromDataFrame()
ibdmix_deserts_gr <- filter(deserts_df, method == "ibdmix") %>% makeGRangesFromDataFrame()

# get intersect of Neanderthal-only deserts inferred by both methods
deserts_gr <- pintersect(ss_deserts_gr, ibdmix_deserts_gr)
```

```{r}
# combined Neanderthal and Denisovan deserts -- Table S9 on page 51 of
# https://www.science.org/doi/suppl/10.1126/science.aad9416/suppl_file/vernot-sm.pdf
ss2_deserts_gr <- tribble(
  ~chrom, ~start, ~end,
  "chr1", 104000000, 114900000,
  "chr3", 76500000, 90500000,
  "chr7", 113600000, 124700000,
  "chr8", 54500000, 65400000
) %>% makeGRangesFromDataFrame()

# get intersect of S* Neanderthal AND Denisovan deserts and IBDmix Neanderthal deserts
deserts2_gr <- pintersect(ss2_deserts_gr, ibdmix_deserts_gr)
```

```{r}
ss_deserts_gr$width <- width(ss_deserts_gr) / 1e6
ibdmix_deserts_gr$width <- width(ibdmix_deserts_gr) / 1e6
deserts_gr$width <- width(deserts_gr) / 1e6

ss2_deserts_gr$width <- width(ss2_deserts_gr) / 1e6
deserts2_gr$width <- width(deserts2_gr) / 1e6
```

```{r}
ss_deserts_gr
ibdmix_deserts_gr
deserts_gr

ss2_deserts_gr
deserts2_gr
```

In the visualizations below, we will define archaic deserts as the intersection of Neanderthal deserts obtained from S* and Neanderthal deserts obtained by IBDmix:

```{r}
# deserts_gr <- deserts2_gr

desert_coords <- deserts_gr %>% as.data.frame() %>% select(chrom = seqnames, start, end)
desert_coords
```

## Load and inspect GeoGenetics metadata

```{r}
metadata <- read_metadata()
```

```{r}
glimpse(metadata)
```

Plot the spatial distribution of all ancient samples in the imputed data:

```{r}
world <- ne_countries(scale = "medium", returnclass = "sf")
sf::st_agr(world) <- "constant"
bbox <- st_as_sfc(st_bbox(c(xmin = -25, xmax = 65, ymin = 25, ymax = 70), crs = st_crs(world)))
western_eurasia <- st_crop(st_make_valid(world), bbox)

metadata %>%
  filter(!is.na(latitude) & !is.na(longitude)) %>%
  st_as_sf(coords = c("longitude", "latitude")) %>%
  st_set_crs(4326) %>%
  ggplot() +
    geom_sf(data = western_eurasia) +
    geom_sf(aes(color = region)) +
    coord_sf(crs = 3035)
```

Out of the various "age" columns in the GeoGenetics metadata, which one is actually usable?

```{r}
filter(metadata, groupAge == "Ancient") %>%
  summarise_at(c("age14C", "ageAverage", "ageRaw"),
               list(total = ~length(.), missing = ~sum(is.na(.x)), prop = ~mean(is.na(.x)))) %>%
  pivot_longer(cols = everything(), names_to = "name") %>%
  separate(name, into = c("measure", "type"), sep = "_", extra = "merge")
```

Looks like `ageAverage` has a value for every individual:

```{r}
metadata %>%
  filter(groupAge == "Ancient") %>%
  ggplot() +
  geom_histogram(aes(ageAverage))
```

## Inspect Neanderthal tracts in ancient and present-day individuals

```{r}
tracts_modern <- read_tracts("Modern", metadata)
tracts_ancient <- read_tracts("Ancient", metadata)

tracts <- rbind(tracts_modern, tracts_ancient)

tracts
```

```{r}
tracts_df <- select(metadata, sampleId, ageAverage, coverage) %>% inner_join(tracts, by = c("sampleId" = "ID"))

tracts_df$age_group <- cut(
  tracts_df$ageAverage,
  breaks = c(Inf, 20e3, 10e3, 5e3, 100, 0),
)

group_levels <- levels(tracts_df$age_group)

tracts_df <- tracts_df %>%
  mutate(
    age_group = as.character(age_group),
    age_group = ifelse(is.na(age_group), "present-day", age_group),
    age_group = factor(age_group, levels = c("present-day", group_levels))
  )
```
```


```{r}
tracts %>%
filter(chrom %in% as.character(seqnames(deserts_gr))) %>%
ggplot(aes(x = start, xend = end, y = ID, yend = ID)) +
  geom_segment(linewidth = 1) +
  geom_rect(data = desert_coords, aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf),
            inherit.aes = FALSE, fill = "red", alpha = 0.1) +
  geom_vline(data = desert_coords, aes(xintercept = start), linetype = "dashed", color = "red") +
  geom_vline(data = desert_coords, aes(xintercept = end), linetype = "dashed", color = "red") +
  labs(x = "position along a chromosome [bp]", y = "each row = tracts in an individual") +
  theme_bw() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid = element_blank()
  ) +
  scale_x_continuous(labels = scales::comma) +
  facet_grid(set ~ chrom, scales = "free") +
  ggtitle("Neanderthal tracts in Eurasians")
```

```{r}
ggplot2::ggsave(paste0("deserts_1+3+7+8.pdf"), width = 13, height = 7)
```



## Analysis of tracts inferred in real data

Convert the IBDmix tracts data frame to `GRanges`:

```{r}
library(BSgenome.Hsapiens.UCSC.hg19)

tracts_gr <- tracts %>% makeGRangesFromDataFrame(keep.extra.columns = TRUE)

seqlengths(tracts_gr) <- seqlengths(BSgenome.Hsapiens.UCSC.hg19)[names(seqlengths(tracts_gr))]
genome(tracts_gr) <- "hg19"

tracts_gr
```

### Fetch gaps from USCS

```{r}
library(ggbio)
library(rtracklayer)
library(plyranges)

mySession <- browserSession()
genome(mySession) <- "hg19"
query <- ucscTableQuery(mySession, table = "gap")

# gap table columns: https://genome.ucsc.edu/cgi-bin/hgTables?db=hg38&hgta_group=map&hgta_track=gap&hgta_table=gap&hgta_doSchema=describe+table+schema
gaps <- getTable(query) %>%
  dplyr::filter(grepl("chr\\d+$", chrom)) %>% as_tibble()

gaps_gr <- makeGRangesFromDataFrame(gaps, starts.in.df.are.0based = TRUE, keep.extra.columns = TRUE, ignore.strand = TRUE)
seqinfo(gaps_gr) <- seqinfo(tracts_gr)

gaps_gr
```

```{r}
gaps_gr %>%
  filter(seqnames %in% seqnames(deserts_gr)) %>%
  autoplot(aes(fill = type), color = NA) +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.position = "bottom")
```

### Analyse tracts in windows

```{r}
windows_gr <- generate_windows(gaps_gr, window_size = 100e3, step_size = 50e3)
# windows_gr <- filter(windows_gr, seqnames == "chr7")

# mark windows falling within archaic deserts
windows_gr$within_desert <- FALSE
windows_gr[queryHits(findOverlaps(windows_gr, deserts_gr))]$within_desert <- TRUE

ancestry_modern_gr <- filter(tracts_gr, set == "Modern") %>% compute_ancestry(windows_gr)
ancestry_ancient_gr <- filter(tracts_gr, set == "Ancient") %>% compute_ancestry(windows_gr)

ancestry_gr <- windows_gr
ancestry_gr$modern <- ancestry_modern_gr$coverage
ancestry_gr$ancient <- ancestry_ancient_gr$coverage

ancestry_gr
```

Average Neanderthal ancestry proportion across all windows in ancient and present-day individuals:

```{r}
ancestry_gr %>%
  as_tibble() %>%
  summarise(
    neand_ancient = mean(ancient, na.rm = TRUE),
    neand_modern = mean(modern, na.rm = TRUE)
  )
```

Average Neanderthal ancestry proportion across all windows in ancient and present-day individuals **within desert regions**:

```{r}
filter(ancestry_gr, within_desert) %>%
  as_tibble() %>%
  group_by(seqnames) %>%
  summarise(
    desert_ancient = mean(ancient, na.rm = TRUE),
    desert_modern = mean(modern, na.rm = TRUE)
  )
```

```{r}
ancestry_gr %>%
  as_tibble() %>%
  filter(within_desert) %>%
  dplyr::rename(chrom = seqnames) %>%
  mutate(chrom = as.character(chrom)) %>%
  group_by(chrom) %>% 
  summarise(
    mean(ancient == 0 & modern > 0),
    mean(ancient > 0 & modern == 0),
    mean((ancient == 0 & modern == 0) | (ancient > 0 & modern > 0))
  ) %>%
  pivot_longer(cols = contains("mean"), values_to = "proportion of sites") %>%
  split(.$chrom)
```

```{r}
pdf("deserts_comparison.pdf", width = 12, height = 8)

for (chrom in as.character(unique(seqnames(deserts_gr)))) {
  p1 <- plot_desert_ancestry(ancestry_gr, deserts_gr, chrom)
  p2 <- plot_desert_correlation(ancestry_gr, chrom)
  
  suppressWarnings(print(cowplot::plot_grid(p1, p2, nrow = 1, rel_widths = c(1, 1))))
}

dev.off()
```

```{r, fig.width=12, fig.height=8}
p1 <- plot_desert_ancestry(ancestry_gr, deserts_gr, "chr7")
p2 <- plot_desert_correlation(ancestry_gr, "chr7")

cowplot::plot_grid(p1, p2, nrow = 1, rel_widths = c(1, 1))
```

## A couple of diagnostics and sanity checks

### Sanity checks of my filtering against Alba's Figure 2. B/C

```{r}
tapply(tracts_df$length, tracts_df$age_group, summary)
```

```{r}
ggplot(tracts_df) +
  geom_density(aes(length, color = age_group)) +
  scale_x_log10()
```

```{r}
ggplot(tracts_df) +
  geom_density(aes(length, color = age_group)) +
  coord_cartesian(xlim = c(0, 1e6))
```

```{r}
ggplot(tracts_df) +
  geom_boxplot(aes(age_group, length, color = age_group)) +
  geom_hline(yintercept = c(50e3, 250e3), linetype = "dashed")
```

```{r}
ggplot(tracts_df) +
  geom_boxplot(aes(age_group, length, color = age_group)) +
  geom_hline(yintercept = c(50e3, 250e3), linetype = "dashed") +
  coord_cartesian(ylim = c(50e3, 250e3)) 
```

## Fitting exponential decay to simulated tracts

### Complete (unfiltered) tract distribution

```{r}
sim_tracts <- read.table(url("https://github.com/bodkan/ku-introgression2024/raw/main/tracts.tsv"), sep = "\t", header = TRUE) %>% as_tibble()
# bin_step <- 10e3
# sim_tracts$bin <- cut(sim_tracts$length, breaks = seq(1, 1e6, by = bin_step - 1), labels = FALSE, include.lowest = TRUE)
# sim_tracts$bin <- cut(sim_tracts$length, breaks = 50, labels = FALSE, include.lowest = TRUE)

average_bins <- aggregate(length ~ bin, data = sim_tracts, FUN = mean)
(bin_step <- mean(diff(average_bins$length)))

# get the bin numbers
bins <- sort(unique(sim_tracts$bin))

# count the tracts in each bin and compute the proportion of tracts in each bin
counts <- as.integer(table(sim_tracts$bin))
props <- counts / sum(counts)

plot(bins, counts, xlab = "Neanderthal tract length bin", ylab = "count of tracts in bin", xlim = c(1, 50), ylim = c(0, 1000))
```

```{r}
r <- 1e-8

fit_fitdistr <- MASS::fitdistr(sim_tracts$length, "exponential")

# plot(bins, props, xlab = "Neanderthal tract length bin", ylab = "count of tracts in bin", xlim = c(1, 50), ylim = c(0, 1000))

lambda_fitdistr <- unname(fit_fitdistr$estimate["rate"])
y_fitdistr <- dexp(bins, rate = lambda_fitdistr * bin_step)
lines(bins, y_fitdistr * sum(counts), col = "red", lty = 2)

t <- 1 / (r * 1 / lambda_fitdistr)
cat("Time of admixture from fitdistr:\n  ", t, "generations\n  ", t * 26.9, "years\n")

lambda_mean <- 1 / mean(sim_tracts$length)
y_mean <- dexp(bins, rate = lambda_mean * bin_step)
lines(bins, y_mean * sum(counts), col = "green", lty = 2)

t <- 1 / (r * 1 / lambda_mean)
cat("Time of admixture from a simple equation:\n  ", t, "generations\n  ", t * 26.9, "years\n")
```

```{r}
r <- 1e-8

plot(bins, counts, xlab = "Neanderthal tract length bin", ylab = "count of tracts in bin", xlim = c(1, 50), ylim = c(0, 1000))

fit_nls <- nls(counts ~ SSasymp(bins, Asym, R0, lrc))
summary(fit_nls)

# https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/SSasymp
lambda_nls <- exp(unname(coef(fit_nls)["lrc"]))
y_nls <- dexp(bins, rate = lambda_nls)
lines(bins, y_nls * sum(counts), col = "red")

t <- 1 / (bin_step * r * 1 / lambda_nls)
cat("Time of admixture from nls:\n  ", t, "generations\n  ", t * 26.9, "years\n")

lines(bins, y_mean * sum(counts), col = "green", lty = 2)

t <- 1 / (r * 1 / lambda_mean)
cat("Time of admixture from a simple equation:\n  ", t, "generations\n  ", t * 26.9, "years\n")
```


### Filtered tracts (truncating the shortest tracts)

```{r}
n_truncated <- 1

truncated_sim_tracts <- sim_tracts %>% filter(bin > n_truncated)

# average_bins <- aggregate(length ~ bin, data = truncated_sim_tracts, FUN = mean)
# (bin_step <- mean(diff(average_bins$length)))

bins <- sort(unique(truncated_sim_tracts$bin))
bins <- c(rep(NA, n_truncated), bins)

counts <- c(rep(NA, n_truncated), as.integer(table(truncated_sim_tracts$bin)))
props <- counts / sum(counts, na.rm = TRUE)

# plot(bins, counts, xlab = "Neanderthal tract length bin", ylab = "count of tracts in bin", xlim = c(1, 50), ylim = c(0, 1000))
```

```{r}
r <- 1e-8

plot(bins, counts, xlab = "Neanderthal tract length bin", ylab = "count of tracts in bin", xlim = c(1, 50), ylim = c(0, 1000))

lines(bins, predict(fit_nls), col = "red")

fit_trunc_nls <- nls(counts ~ SSasymp(bins, Asym, R0, lrc))
summary(fit_trunc_nls)
lines(bins[!is.na(counts)], predict(fit_trunc_nls), col = "blue")

fit_trunc_nls2 <- nls(counts ~ SSasymp(bins, Asym, R0, lrc), weights = sqrt(1 / bins))
summary(fit_trunc_nls2)
lines(bins[!is.na(counts)], predict(fit_trunc_nls2), col = "green")

# https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/SSasymp
# https://stats.stackexchange.com/questions/318971/fitting-exponential-decay-with-negative-y-values
lambda_trunc_nls <- exp(coef(fit_trunc_nls)["lrc"])
# y_trunc_nls <- dexp(bins[!is.na(counts)], rate = lambda_trunc_nls)
# lines(bins[!is.na(counts)], y_trunc_nls * sum(counts, na.rm = TRUE) + coef(fit_trunc_nls)["Asym"], col = "cyan", lty = 2)

t <- 1 / (bin_step * r * 1 / lambda_trunc_nls)
cat("Result from nls: ", t, "\n")

lambda_trunc_nls2 <- exp(coef(fit_trunc_nls2)["lrc"])
# y_trunc_nls2 <- dexp(bins[!is.na(counts)], rate = lambda_trunc_nls2)
# lines(bins[!is.na(counts)], y_trunc_nls2 * sum(counts, na.rm = TRUE) + coef(fit_trunc_nls2)["Asym"], col = "green", lty = 2)

legend("topright", fill = c("blue", "green", "red"), #, "cyan", "green"),
       legend = c("truncated nls", "truncated nls (weighted)", "full nls fit")) #,
                  # "truncated nls (dexp)", "truncated nls (weighted, dexp)"))

t <- 1 / (bin_step * r * 1 / lambda_trunc_nls2)
cat("Result from nls (weighted): ", t, "\n")
```


## Fitting exponential decay to empirical tracts

```{r}
bin_step <- 25e3

tract_bins <- tracts_df %>%
  filter(set == "Modern") %>%
  # filter(sampleId == "Kostenki") %>%
  # filter(ageAverage < 10000) %>%
  # filter(ageAverage == max(ageAverage)) %>%
  # mutate(bin = cut(length, breaks = seq(1, max(length) + bin_step, by = bin_step - 1), labels = FALSE, include.lowest = TRUE)) %>%
  mutate(bin = cut(length, breaks = seq(1, 1e6, by = bin_step - 1), labels = FALSE, include.lowest = TRUE)) %>%
  filter(!is.na(bin))

tract_bins %>%
  group_by(bin) %>%
  summarise(min(length), max(length), mean(length), n())
```

```{r}
n_truncated <- min(tract_bins$bin) - 1

bins <- sort(unique(tract_bins$bin))
bins <- c(1:n_truncated, bins)

counts <- as.integer(table(tract_bins$bin))
counts <- c(rep(NA, n_truncated), counts)

props <- counts / sum(counts, na.rm = TRUE)

# plot(bins, props, xlab = "Neanderthal tract length bin", ylab = "count of tracts in bin", log = "y")
plot(bins, props, xlab = "Neanderthal tract length bin", ylab = "count of tracts in bin", ylim = c(0, 0.3))
```

```{r}
r <- 1e-8

# plot(bins, props, xlab = "Neanderthal tract length bin", ylab = "count of tracts in bin", log = "y")
plot(bins, props, xlab = "Neanderthal tract length bin", ylab = "count of tracts in bin", ylim = c(0, 0.3))

fit_trunc_nls2 <- nls(props ~ SSasymp(bins, Asym, R0, lrc), weights = sqrt(1/bins))
summary(fit_trunc_nls2)
lines(bins[!is.na(counts)], predict(fit_trunc_nls2), col = "green")

# https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/SSasymp
# https://stats.stackexchange.com/questions/318971/fitting-exponential-decay-with-negative-y-values
# lambda_trunc_nls2 <- exp(coef(fit_trunc_nls2)["lrc"])
# y_trunc_nls2 <- dexp(bins[!is.na(counts)], rate = lambda_trunc_nls2)
# y_trunc_nls2 <- y_trunc_nls2 * sum(counts, na.rm = TRUE) / sum(y_trunc_nls2) + coef(fit_trunc_nls2)["Asym"]
# lines(bins[!is.na(counts)], y_trunc_nls2, col = "blue", lty = 2)

# https://www.science.org/doi/10.1126/sciadv.abm7047#:~:text=Within%20this%20time%20frame%2C%20we,of%2023.2%20Â±%203.0%20years
```

```{r}
lrc_est <- coef(fit_trunc_nls2)["lrc"] %>% unname()

# calculate the estimate of lambda
lambda_est <- exp(lrc_est)

# extract the standard error of lrc
lrc_se <- summary(fit_trunc_nls2)$parameters["lrc", "Std. Error"]

# use the delta method to approximate the standard error of lambda
lambda_se <- lambda_est * lrc_se

# calculate the confidence interval for lambda
alpha <- 0.05 # for a 95% confidence interval
z <- qnorm(1 - alpha / 2)
ci_lower <- lambda_est - z * lambda_se
ci_upper <- lambda_est + z * lambda_se

t_est <- 1 / (bin_step * r * 1 / lambda_est)
t_lower <- 1 / (bin_step * r * 1 / ci_lower)
t_upper <- 1 / (bin_step * r * 1 / ci_upper)
cat("Mean admixture time:", t_est, "generations,", t_est * 26.9, "years\n",
 "Lower CI boundary:", t_lower, "generations,", t_lower * 26.9, "years\n",
 "Upper CI boundary:", t_upper, "generations,", t_upper * 26.9, "years\n")
```


```{r}
tracts_df$age_group <- cut(
  tracts_df$ageAverage,
  breaks = c(Inf, 20e3, 10e3, 0)
)

group_levels <- levels(tracts_df$age_group)

tracts_df <- tracts_df %>%
  mutate(
    age_group = as.character(age_group),
    age_group = ifelse(is.na(age_group), "present-day", age_group),
    age_group = factor(age_group, levels = c("present-day", group_levels))
  )
```

```{r}
age_groups <- unique(tracts_df$age_group)

results <- lapply(age_groups, function(x) {
bin_step <- 10e3

tract_bins <- tracts_df %>% filter(age_group == x)

if (!nrow(tract_bins)) return(list(t_admix = NA, t_admix_lower = NA, t_admix_upper = NA))

tract_bins <- tract_bins %>% 
  mutate(bin = cut(length, breaks = seq(1, 1e6, by = bin_step - 1), labels = FALSE, include.lowest = TRUE)) %>%
  filter(!is.na(bin))

r <- 1e-8
n_truncated <- min(tract_bins$bin) - 1

bins <- sort(unique(tract_bins$bin))
bins <- c(1:n_truncated, bins)

counts <- as.integer(table(tract_bins$bin))
counts <- c(rep(NA, n_truncated), counts)

fit_trunc_nls2 <- nls(counts ~ SSasymp(bins, Asym, R0, lrc), weights = bins)

lrc_est <- coef(fit_trunc_nls2)["lrc"] %>% unname()
lrc_se <- summary(fit_trunc_nls2)$parameters["lrc", "Std. Error"]

lambda_est <- exp(lrc_est)
lambda_se <- lambda_est * lrc_se

alpha <- 0.05
z <- qnorm(1 - alpha / 2)
ci_lower <- lambda_est - z * lambda_se
ci_upper <- lambda_est + z * lambda_se

t_est <- 1 / (bin_step * r * 1 / lambda_est) * 26.9
t_lower <- 1 / (bin_step * r * 1 / ci_lower) * 26.9
t_upper <- 1 / (bin_step * r * 1 / ci_upper) * 26.9

tibble(age_group = x, t_admix = t_est, t_admix_lower = t_lower, t_admix_upper = t_upper)
}) %>% do.call(rbind, .)
```

```{r}
ggplot(results) +
  geom_pointrange(aes(x = age_group, y = t_admix, ymin = t_admix_lower, ymax = t_admix_upper))
```







```{r}
highest_cov <- tracts_df %>%
  distinct(sampleId, age_group, coverage) %>%
  group_by(age_group) %>%
  arrange(-coverage) %>%
  slice_head(n = 3)
highest_cov

bin_step <- 5e3

bins_df <- tracts_df %>%
  filter(sampleId %in% highest_cov$sampleId) %>%
  group_by(age_group) %>%
  mutate(bin = cut(length, breaks = seq(1, 1e6, by = bin_step - 1), labels = FALSE, include.lowest = TRUE)) %>%
  filter(!is.na(bin)) %>%
  group_by(age_group, bin) %>%
  summarise(count = n()) %>%
  mutate(prop = count / sum(count))

ggplot(bins_df, aes(bin, prop, color = age_group, group = age_group)) +
  geom_point() +
  stat_smooth(method = "nls", formula = y ~ SSasymp(x, Asym, R0, lrc), se = FALSE) +
  scale_x_log10()
```




## Chen _et al._ tracts

```{r}
chen_tracts <- read_tsv("data/Chen et al. - Neanderthal sequence in 1000 genome.50kb.txt") %>%
  filter(anc == "EUR") %>%
  select(ID, chrom = chr, start, end) %>%
  mutate(chrom = paste0("chr", chrom), set = "Chen et al.")
```

```{r}
all_tracts <- bind_rows(tracts, chen_tracts)
```

```{r}
group_by(all_tracts, set) %>% tally()
```

### Comparison of Chen _at al._'s and Alba's results

```{r}
all_tracts %>%
filter(set != "Ancient", chrom %in% as.character(unique(seqnames(deserts_gr)))) %>%
ggplot(aes(x = start, xend = end, y = ID, yend = ID)) +
  geom_segment(linewidth = 1) +
  geom_rect(data = desert_coords, aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf), inherit.aes = FALSE, fill = "red", alpha = 0.1) +
  geom_vline(data = desert_coords, aes(xintercept = start), linetype = "dashed", color = "red") +
  geom_vline(data = desert_coords, aes(xintercept = end), linetype = "dashed", color = "red") +
  labs(x = "position along a chromosome [bp]", y = "each row = tracts in an individual") +
  theme_bw() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid = element_blank()
  ) +
  scale_x_continuous(labels = scales::comma) +
  facet_grid(set ~ chrom, scales = "free") +
  ggtitle("Neanderthal tracts in Eurasians")
```

### Deserts in the Chen _et al._ data

```{r}
chen_gr <- chen_tracts %>% makeGRangesFromDataFrame(keep.extra.columns = TRUE)

seqlengths(chen_gr) <- seqlengths(BSgenome.Hsapiens.UCSC.hg19)[names(seqlengths(chen_gr))]
genome(chen_gr) <- "hg19"

chen_gr
```

```{r}
ancestry_chen_gr <- chen_gr %>% compute_ancestry(windows_gr)

ancestry_gr$chen <- ancestry_chen_gr$coverage

ancestry_gr
```

```{r}
saveRDS(ancestry_gr, "ancestry_gr.rds")
```

```{r}
ancestry_gr <- readRDS("ancestry_gr.rds")
```

```{r, fig.width=12, fig.height=8}
plot_desert_ancestry2(ancestry_gr, deserts_gr, "chr1")
```

```{r, fig.width=12, fig.height=8}
plot_desert_ancestry2(ancestry_gr, deserts_gr, "chr3")
```

```{r, fig.width=12, fig.height=8}
plot_desert_ancestry2(ancestry_gr, deserts_gr, "chr7")
```

```{r, fig.width=12, fig.height=8}
plot_desert_ancestry2(ancestry_gr, deserts_gr, "chr8")
```
